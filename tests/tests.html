<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chore Chart - Unit Tests</title>
    <link rel="stylesheet" href="../src/style.css">
    <link rel="stylesheet" href="../src/fonts.css">
</head>

<body>
    <h1>ðŸ§ª Chore Chart Unit Tests</h1>
    <div class="summary" id="summary">Running...</div>
    <div id="results"></div>

    <script src="../src/vendor/sql-wasm.js"></script>
    <script src="../src/storage-strategy.js"></script>
    <script src="../src/db.js"></script>
    <script src="../src/repository.js"></script>
    <script>
        // Use a local wasm path directly for the test
        window.SQL_WASM_PATH = '../src/vendor/sql-wasm.wasm';

        // Stub DOMContentLoaded to prevent app.js init() from running
        const origAddEventListener = document.addEventListener;
        document.addEventListener = function (type, fn) {
            if (type === 'DOMContentLoaded') return; // skip
            origAddEventListener.call(this, type, fn);
        };
    </script>
    <script src="../src/app.js"></script>
    <script>
        // Restore
        document.addEventListener = origAddEventListener;
    </script>

    <script>
        // â”€â”€ Minimal Test Framework â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const suites = [];
        let currentSuite = null;

        function describe(name, fn) {
            currentSuite = { name, tests: [], beforeEachFn: null };
            suites.push(currentSuite);
            fn();
        }

        function beforeEach(fn) {
            if (currentSuite) currentSuite.beforeEachFn = fn;
        }

        function it(name, fn) {
            if (currentSuite) currentSuite.tests.push({ name, fn });
        }

        function expect(actual) {
            return {
                toBe(expected) {
                    if (actual !== expected) throw new Error(`Expected ${expected}, got ${actual}`);
                },
                toBeGreaterThan(n) {
                    if (!(actual > n)) throw new Error(`Expected ${actual} > ${n}`);
                },
                toContain(item) {
                    if (!actual.includes(item)) throw new Error(`Expected array to contain ${item}`);
                }
            };
        }

        // â”€â”€ Test Runner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        async function runTests() {
            const SQL = await initSqlJs({
                locateFile: file => `https://sql.js.org/dist/${file}`
            });

            let totalPass = 0, totalFail = 0;
            const resultsDiv = document.getElementById('results');

            for (const suite of suites) {
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'suite';

                const header = document.createElement('div');
                header.className = 'suite-header';
                header.innerHTML = `<span>${suite.name}</span>`;
                suiteDiv.appendChild(header);

                let suitePass = 0, suiteFail = 0;

                for (const test of suite.tests) {
                    let error = null;

                    // Fresh DB for each test using direct assignment to the global db.js variable
                    localStorage.removeItem(DB_NAME);
                    _db = { isNative: false, client: new SQL.Database() };

                    if (suite.beforeEachFn) {
                        try { await suite.beforeEachFn(); } catch (e) { error = e; }
                    }

                    if (!error) {
                        try { await test.fn(); } catch (e) { error = e; console.error('TEST ERROR:', test.name, e); }
                    }
                    if (error && suite.beforeEachFn && error.message === undefined) console.error('BEFORE EACH ERROR:', suite.name, error);

                    const passed = !error;
                    if (passed) { totalPass++; suitePass++; }
                    else { totalFail++; suiteFail++; }

                    const row = document.createElement('div');
                    row.className = `test-row ${passed ? 'pass' : 'fail'}`;
                    row.innerHTML = `
                        <span class="test-icon">${passed ? 'âœ“' : 'âœ—'}</span>
                        <div class="test-name">
                            ${test.name}
                            ${error ? `<div class="test-error">${error.stack || error.message || error}</div>` : ''}
                        </div>
                    `;
                    suiteDiv.appendChild(row);
                }

                header.innerHTML = `<span>${suite.name}</span> <span class="${suiteFail ? 'fail' : 'pass'}" style="float:right; font-weight:normal;">${suiteFail ? suiteFail + ' failed' : suitePass + ' passed'}</span>`;
                resultsDiv.appendChild(suiteDiv);
            }

            const summary = document.getElementById('summary');
            summary.innerHTML = `
                <span class="pass">${totalPass} passed</span> Â· 
                <span class="${totalFail ? 'fail' : ''}">${totalFail} failed</span> Â· 
                ${totalPass + totalFail} total
            `;
            document.title = totalFail
                ? `âœ— ${totalFail} Failed - Unit Tests`
                : `âœ“ All Passed - Unit Tests`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        describe('Database Schema & Seeding', () => {
            beforeEach(async () => { await createSchema(); });

            it('seeds default actors and chores', async () => {
                const people = await ChoreRepository.getAllPeople();
                expect(people.length).toBe(3);

                const chores = await ChoreRepository.getAllChores();
                expect(chores.length).toBe(4);
            });

            it('seeds default settings accurately', async () => {
                const title = await ChoreRepository.getSetting('chart_title');
                expect(title).toBe('Chore Chart');

                const maxCells = await ChoreRepository.getMaxMarkersPerCell();
                expect(maxCells).toBe(2);
            });

            it('orders days correctly based on week_start_day', async () => {
                await ChoreRepository.setWeekStartDay('Mon');
                let days = await getOrderedDays();
                expect(days[0]).toBe('Mon');
                expect(days[6]).toBe('Sun');

                await ChoreRepository.setWeekStartDay('Sun');
                days = await getOrderedDays();
                expect(days[0]).toBe('Sun');
            });
        });

        describe('Actor & Group Operations', () => {
            beforeEach(async () => { await createSchema(); });

            it('adds and updates user entities', async () => {
                await ChoreRepository.addPerson('Bob', 'BOB', '#fff');
                let people = await ChoreRepository.getAllPeople();
                let newPerson = people.find(p => p.name === 'Bob');
                expect(newPerson.initials).toBe('BOB');

                await ChoreRepository.updateActor(newPerson.id, { initials: 'B' });
                people = await ChoreRepository.getAllPeople();
                newPerson = people.find(p => p.id === newPerson.id);
                expect(newPerson.initials).toBe('B');
            });

            it('calculates group depth and limits additions correctly', async () => {
                await ChoreRepository.addGroup('G1', 'G1', '#000');
                let groups = await ChoreRepository.getAllGroups();
                let g1 = groups.find(g => g.name === 'G1');

                await ChoreRepository.addGroup('G2', 'G2', '#000', false, [g1.id]);
                groups = await ChoreRepository.getAllGroups();
                let g2 = groups.find(g => g.name === 'G2');

                const depth = await ChoreRepository.getGroupDepth(g2.id);
                expect(depth).toBe(2);

                // Nesting beyond limit
                await ChoreRepository.addGroup('G3', 'G3', '#000', false, [g2.id]);
                groups = await ChoreRepository.getAllGroups();
                let g3 = groups.find(g => g.name === 'G3');

                const canAddG3ToG1 = await ChoreRepository.canAddMember(g1.id, g3.id);
                expect(canAddG3ToG1).toBe(false); // Circular dependency prevention!
            });
        });

        describe('Chores & Assignments', () => {
            beforeEach(async () => { await createSchema(); });

            it('adds, modifies, and sorts chores', async () => {
                await ChoreRepository.addChore('Mopping');
                let chores = await ChoreRepository.getAllChores();
                let mopping = chores[chores.length - 1];
                expect(mopping.name).toBe('Mopping');

                await ChoreRepository.updateChoreOrders([mopping.id, ...chores.filter(c => c.id !== mopping.id).map(c => c.id)]);
                chores = await ChoreRepository.getAllChores();
                expect(chores[0].name).toBe('Mopping'); // Mopping moved to front
            });

            it('restricts assignments based on max markers', async () => {
                await ChoreRepository.setMaxMarkersPerCell(1);
                const people = await ChoreRepository.getAllPeople();
                const chores = await ChoreRepository.getAllChores();

                let success = await ChoreRepository.addAssignment(chores[0].id, 0, people[0].id);
                expect(success).toBe(true);

                let success2 = await ChoreRepository.addAssignment(chores[0].id, 0, people[1].id);
                expect(success2).toBe(false); // Exceeds cap of 1

                let assignments = await ChoreRepository.getAllAssignments();
                expect(assignments[`${chores[0].id}-0`].length).toBe(1);
            });

            it('clears assignments successfully', async () => {
                const people = await ChoreRepository.getAllPeople();
                const chores = await ChoreRepository.getAllChores();

                await ChoreRepository.setAssignment(chores[0].id, 3, people[0].id);
                let assignments = await ChoreRepository.getAllAssignments();
                expect(Object.keys(assignments).length).toBeGreaterThan(0);

                await ChoreRepository.clearAllAssignments();
                assignments = await ChoreRepository.getAllAssignments();
                expect(Object.keys(assignments).length).toBe(0);
            });
        });

        describe('Rotations', () => {
            beforeEach(async () => { await createSchema(); });

            it('assigns rotations wrapping across the core days', async () => {
                await ChoreRepository.addPerson('Alice', 'AL', '#111');
                await ChoreRepository.addPerson('Bob', 'BO', '#222');
                let people = await ChoreRepository.getAllPeople();
                let alice = people.find(p => p.name === 'Alice');
                let bob = people.find(p => p.name === 'Bob');

                await ChoreRepository.addGroup('Team', 'TM', '#000', false, [alice.id, bob.id]);
                const groups = await ChoreRepository.getAllGroups();
                let tm = groups.find(g => g.name === 'Team');

                const chores = await ChoreRepository.getAllChores();

                // Rotations inject starting with Alice on Day 5 (Saturday for Mon-Start)
                await ChoreRepository.assignGroupRotation(chores[0].id, tm.id, alice.id, 5);

                const assignments = await ChoreRepository.getAllAssignments();
                expect(assignments[`${chores[0].id}-5`][0].name).toBe('Alice');
                expect(assignments[`${chores[0].id}-6`][0].name).toBe('Bob');
                expect(assignments[`${chores[0].id}-0`][0].name).toBe('Alice'); // Wrapped to Monday
            });
        });

        // â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        runTests();
    </script>
</body>

</html>